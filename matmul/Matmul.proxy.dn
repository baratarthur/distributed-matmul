
component provides matmul.Matmul(AdaptEvents) requires network.rpc.RPCUtil connection, data.IntUtil iu, data.json.JSONEncoder je, data.StringUtil su {
	Address remotes[] = new Address[](new Address("dana-remote-1", 8081),new Address("dana-remote-2", 8082))
	int addressPointer = 0
	Mutex pointerLock = new Mutex()

	Line Matmul:calcLine(Line line, Matrix B) {
		CalcLineParamsFormat params = new CalcLineParamsFormat(lineToChar(line), matrixToChar(B))
		char requestBody[] = je.jsonFromData(params)
		Request req = new Request(buildMetaForMethod("calcLine"), requestBody)
		Response res = distribute(req)
		return charToLine(res.content)
	}

	Matrix Matmul:multiply(Matrix A, Matrix B) {
		MultiplyParamsFormat params = new MultiplyParamsFormat(matrixToChar(A), matrixToChar(B))
		char requestBody[] = je.jsonFromData(params)
		Request req = new Request(buildMetaForMethod("multiply"), requestBody)
		Response res = distribute(req)
		return charToMatrix(res.content)
	}

	char[] Matmul:matrixToChar(Matrix matrix) {
        char result[] = new char[]("[")

        for(int i=0; i < matrix.lines.arrayLength; i++) {
            result = new char[](result, "[")
            int currentLine[] = matrix.lines[i].line

            for(int j=0; j<currentLine.arrayLength; j++) {
                if (j == currentLine.arrayLength - 1) result = new char[](result, iu.makeString(currentLine[j]))
                else result = new char[](result, iu.makeString(currentLine[j]), ",")
            }

            if (i == matrix.lines.arrayLength - 1) result = new char[](result, "]")
            else result = new char[](result, "],")
        }

        result = new char[](result, "]")
        return result
	}

	char[] Matmul:lineToChar(Line line) {
        char result[] = new char[]("[")
        int lineValue[] = line.line

        for(int i=0; i<lineValue.arrayLength; i++) {
            if (i == lineValue.arrayLength - 1) result = new char[](result, iu.makeString(lineValue[i]))
            else result = new char[](result, iu.makeString(lineValue[i]), ",")
        }

        result = new char[](result, "]")
        return result
	}

	Matrix Matmul:charToMatrix(char matrixChar[]) {
        String linesChar[] = null
        Matrix resultMatrix = new Matrix()
        char acc[] = ""
        bool startRecording = false

        for(int i=1; i < matrixChar.arrayLength - 1; i++) {
            if(matrixChar[i] == "[") startRecording = true
            if(startRecording) acc = new char[](acc, matrixChar[i])
            if(matrixChar[i] == "]") {
                startRecording = false
                linesChar = new String[](linesChar, new String(acc))
                acc = ""
            }
        }

        for(int k=0; k < linesChar.arrayLength; k++) {
            char lineString[] = linesChar[k].string
            resultMatrix.lines = new Line[](resultMatrix.lines, charToLine(lineString))
        }


        return resultMatrix
	}

	Line Matmul:charToLine(char lineString[]) {
        char onlyNumbers[] = su.subString(lineString, 1, lineString.arrayLength - 2)
        String lineStrings[] = su.explode(onlyNumbers, ",")

        int lineIntAcc[] = new int[]()
        for(int j=0; j < lineStrings.arrayLength; j++) {
            lineIntAcc = new int[](lineIntAcc, iu.intFromString(su.trim(lineStrings[j].string)))
        }

        return new Line(lineIntAcc)
	}

	Metadata[] buildMetaForMethod(char method[]) {
		Metadata metaMethod = new Metadata("method", method)
		return new Metadata[](metaMethod)
	}

	Response distribute(Request r) {
		connection.connect(remotes[addressPointer])
		mutex(pointerLock) {
			addressPointer++
			if(addressPointer >= remotes.arrayLength) addressPointer = 0
		}
		return connection.make(r)
	}

	void AdaptEvents:active() {
	}

	void AdaptEvents:inactive() {
	}
}
